## 객체 vs 클래스
객체를 설명하기 전에 클래스를 알아야합니다.
클래스는 객체를 나타낼 수 있는 정적인 도구 역할을 합니다.  클래스에 객체의 상태, 행위를 정의할 수 있고 그러한 클래스를 사용하여 객체를 만들 수 있습니다.
객체는 상태와 행위를 가지며 스스로 책임을 집니다. 객체와 클래스를 생각할 때, 클래스를 먼저 정의하는 것이 아니라 객체의 속성과 행위를 정의하는 것을 먼저 해야합니다.

## 객체지향이란?
객체지향은 객체의 책임, 역할 그리고 객체 간의 협력을 통해 코드를 바라보는 것이라 할 수 있습니다.
객체는 각각 책임이 정의되어 있고 그 책임이 역할이 됩니다. 개발자는 이러한 객체를 사용하여 협력을 할 수 있는데, 협력은 메시지를 통해 할 수 있습니다. 메시지는 객체 내 메소드를 통해 전달이 됩니다. 객체지향적인 개발을 통해 다형성, 캡슐화, 추상화, 상속과 같은 장점을 얻을 수 있습니다.

## 변수의 종류
변수는 크게 4가지로 나누어져있습니다.
우선, 클래스가 처음 호출될 때 생성되어 사라질 때까지 존재하는 **클래스 변수**, 
객체 내에서 존재하는 **인스턴스 변수**, 메소드 내에서 존재하는 **지역 변수**, 마지막으로 메소드 파라미터를 통해 받을 수 있는 **매개 변수**가 있습니다.

## Primitive Type
Primitive Type은 기본 타입을 얘기하고 자바에선 8가지가 존재합니다.
byte(1), boolean(1), char(2), short(2), int(4), float(4), double(8), long(8)가 존재합니다.
// Primitive Type은 실제 값이 저장되는 공간으로 스택 메모리에 저장됩니다.

## Reference Type
Primitive Type을 제외한 타입을 Reference Type이라고 부를 수 있습니다.
레퍼런스 타입은 배열, 인터페이스, 컬렉션, 우리가 정의하는 객체 등 자바 내에서 매우 다양하게 존재합니다.

// 래퍼런스 타입은 값이 저장되어 있는 주소 값을 저장하는 공간으로 힙 영역에 저장된다.

## 자바의 ==, equals()
자바에서는 두 개의 객체를 비교할 수 있는데 ==, equals 메소드를 통해 비교할 수 있습니다. ==는 두 객체간의 동일성을 비교할 수 있고, equals 메소드는 두 객체의 동등성을 비교할 수 있습니다. 동일성이랑 모든 것이 동일한 객체를 얘기하고 동등성이란 동일한 값을 가진 객체를 얘기합니다.
보통 두 객체를 비교할 때 Object의 equals는 자기 자신이랑만 같다고 비교하기 때문에 equals를 오버라이딩하여 재정의한 후 사용합니다. 

## 배열
배열은 값을 연속적으로 담기 위한 자료구조입니다.
배열을 사용하게 되면 변수를 일일히 선언하지 않고도 관련된 변수들을 하나로 묶어 사용할 수 있습니다. 예를 들어, 동전이라는 변수를 선언한다고 할 때, 배열을 사용하지 않으면 100원, 500원 변수를 따로 생성해야 하지만 배열을 사용하게 되면 coin 배열을 선언하고 순서대로 초기화 하게 되면 인덱스를 사용하여 접근할 수 있습니다.

## JVM
JVM은 자바가 OS에 상관없이 동작할 수 있도록 해주는 것으로 Java Virtual Machine의 약자입니다.

## Garbage Collection
자바에서는 개발자가 직접 메모리를 관리하지 않기 때문에 가바지 컬렉터가 더 이상 필요없는 객체들을 찾아 지워줄 수 있다. 그것을 Garbage Collection이라고 합니다.

GC를 이해하기 전에 우선 ‘stop-the-world’에 대해서 알아야합니다. 이것은 GC가 실행될 때 JVM이 다른 실행되는 작업 멈추고 GC가 끝나면 실행된다는 것을 말합니다.

우리가 사용하는 Hotspot JVM에서는 크게 2가지 영역이 존재하는데 Young 영역과 Old 영역입니다. Young 영역부터 보게 되면 새롭게 생성된 객체들이 살아있는 영역이고 대부분의 객체는 금방 접근 불가능 상태가 되기 때문에 Young 영역에서 Old 영역으로 이동합니다. Young의 흐름을 보면, Eden 영역에 새로운 객체들이 생성되고 이 영역에서 GC가 발생한 후 살아남은 객체들은 Survivor 영역 중 하나로 이동합니다. 그렇게 Survivor 영역에 객체가 쌓이게 되고 가득차게 된다면 또다른 Survivor 영역으로 이동합니다. 이때 첫번째 Survivor 영역은 비어있는 상태가 됩니다. 이 과정을 반복해도 살아남은 객체들은 Old 영역으로 가게 됩니다.


### G1 Gc
G1 GC는 Young, Old 방식이 아닌 바둑판 영역에 객체를 할당하고 GC를 실행하는 방식으로 알고 있습니다.
해당 영역에 객체들이 가득차면 다른 영역에 객체를 할당하고 그 영역에 GC를 실행합니다.


## 접근 제어자
자바에서 접근 제어자는 Public, Protected, default, Private 4가지가 있습니다. Public은 모든 곳에서 접근할 수 있고 Protected는 같은 패키지 그리고 상속 받은 객체에 대해 접근할 수 있습니다. default는 같은 패키지내에서 접근이 가능하고 Private는 클래스 내에서만 접근이 가능하다는 것을 말합니다.

## 상속
자바에서 상속을 생각할 땐, 부모 자식간의 상속보단 확장의 개념으로 생각하는 게 맞다고 생각합니다.  A 클래스를 상속 받은 B 클래스는 A 클래스에 정의된 메소드를 오버라이딩, 오버로딩을 통해 확장할 수 있습니다. 또한 A 클래스의 메소드들을 그대로 사용하고 또 B 클래스에만 존재하는 메소드들을 정의할 수 있습니다. 이런 것을 보면 상속은 확장의 개념이라고 생각할 수 있습니다. 상속과 함게 나오는 것이 implements 인데 implements는 다중 상속이 가능하지만 extends는 하나의 상속만 가능하다는 특징이 있습니다.

## Object
Object 클래스는 자바의 모든 클래스의 상위 클래스이기 때문에 
Import 문을 사용하지 않아도 사용할 수 있습니다.
Object 클래스 내에는  clone, equals, hashcode, getClass와 같은 메소드들이 정의되어 있습니다.

## equals, hashcode
equals는 동등성을 hashcode는 동일성을 보여줍니다.
Object 클래스에서 equals를 찾아보게 되면 자기 자신의 객체와 == 비교하는 것을 볼 수 있습니다. 그렇기 때문에 우리는 equals를 사용하여 동등성을 비교하기 위해서는 재정의하여 사용하여야 합니다. 하지만 이렇게 equals만 재정의 하게 되면 hash 관련 함수를 사용할 때 문제가 생기게 됩니다. 분명 같은 값을 가진 객체를 선언하였고 이퀄 비교 또한 true로 나왔으나 hashmap.put을 하게 되면 사이즈가 2가 나오게 됩니다. 이러한 문제를 해결하기 위해서는 hashcode 메소드를 오버라이딩하여 문제를 해결할 수 있습니다.

결론은 이퀄을 재정의할 때 해쉬코드도 재정의하여 사용하는 것이 맞습니다.