# 봉준터디 <2>

## 1. https://www.naver.com 을 접속할 때 일어나는 일

브라우저가 URL에 적힌 값을 파싱하여 HTTP Request Message를 만들고 전송 요청을 한다. 이 때, URL 주소 중에서 도메인 네임 부분을 DNS 서버에 검색하고, DNS 서버에서 해당 URL에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
(DNS 서버에서 URL을 찾을 때, 브라우저 -> hosts 파일 -> DNS Cache 순서로 도메인에 매칭되는 ip를 찾는다.)

페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.

도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.

검색된 웹 페이지 데이터는 또 다시 HTTP 프토토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 클라이언트로 전송된다.

도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.

## 2. JVM의 구조와 Java의 실행 방식을 설명해주세요.

Java Virtual Machine의 약자를 따서 부르는 용어로 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것이다. GC를 수행하며 스택 기반의 가상머신이다.

JVM의 구성은 크게 4가지 (class Loader, Execution Engine, Garbage Collector, Runtime Data Area)로 나뉜다.

### 2-1. Class Loader

.java 파일을 컴파일러가 컴파일하면 .class(바이트코드) 파일이 생성된다.
이렇게 생성된 클래스 파일들을 엮어서 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Area로 적재하는 역할을 Class Loader가 한다.
(자바 애플리케이션이 실행 중일 때 이런 작업이 수행된다.)

### 2-2. Execution Engine

Class Loader에 의해 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경해 명령어 단위로 실행하는 역할을 한다.

명령어를 하나 하나 실행하는 인터프리터 방식과 JIT 컴파일러를 이용하는 방식을 사용한다.
JIT 컴파일러는 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행하는 것으로 성능을 높이는 방식이다.

### 2-3. Garbage Collector

GC는 Heap 메모리 영역에 생성된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다.

GC가 역할을 하는 시간은 정확히 언제인지를 알 수 없다. 
또 다른 특징은 GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시정지 된다. 특히 Full GC가 일어나서 수 초간 모든 쓰레드가 정지한다면 장애로 이어지는 치명적인 문제가 발생할 수 있다.

### 2-4. Runtime Data Area

JVM 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.

이 영역은 Method Area, Heap Area, Stack Area, PC register, Native Method Stack로 나눌 수 있다.

* Method Area: 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보 같은 필드 정보, 메소드 이름, 리턴 타입, 파라미터, 메소드 정보, type 정보, constant pool, static 변수, final class 변수 등이 생성되는 영역이다.

* Stack Area: 지역 변수, 파라미터, 리턴 값 등이 생성되는 영역이다.

* PC register: 쓰레드가 생성될 때마다 생성되는 영역으로 Program Counter. 즉 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다.

* Native method stack: 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다.

### 2-5. Heap Area & Garbage Collector

힙 영역은 5개의 영역 (eden, survivor1, survivor2, old, permanent)으로 나뉜다.

JDK7 까지는 permanent 영역이 heap에 존재했는데, JDK8 부터는 permanent 영역은 사라지고 일부가 meta space 영역으로 변경되었다. meta space 영역은 native stack 영역에 포함되어있다.

GC는 Minor GC와 Major GC로 나뉜다.

#### 2-5-1. Minor GC

1. 최초에 객체가 생성되면 Eden 영역에 생성된다.
2. Eden 영역에 객체가 가득차게 되면 첫 번째 GC가 일어난다.
3. Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.
4. 하나의 Survivor 영역이 가득차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 이동한다. 그리고 가득 찬 Survivor 영역은ㄴ 아무 데이터도 없는 상태로 된다.
5. 이 과정을 반복하다가 계속 살아남아 있는 객체는 Old 영역으로 이동하게 된다.

#### 2-5-2. Major GC (Full GC)

1. Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.
2. 참조되지 않은 객체들을 모아 한 번에 제거한다.
    - Minor GC보다 시간이 훨씬 많이 걸리고 실행 중에 GC를 제외한 모든 쓰레드가 중지된다.

## 3. 컬렉션 프레임워크에 대해서 설명해주세요.

Java Collection은 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리할 수 있는 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 한다.

List, Set, Map이 있다.

## 4. 제네릭에 대해서 설명해주세요.

제네릭은 자바의 타입 안정성을 맡고 있다. 컴파일 과정에서 타입 체크를 해주어 
타입의 안정성을 높이고 형 변환의 번거로움을 줄여준다.

* <\?>: 와일드 카드
* extends T: 상한 경계
* ? super T: 하한 경계

## 5. 애노테이션에 대해서 설명해주세요.

애노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다.

## 6. 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?

오버라이딩은 상위 클래스의 메소드를 재정의 하는 것을 의미한다. 런타임 다형성이기도 하다.

오버로딩은 같은 클래스 내에 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미한다. 컴파일 타임의 다형성이기도 하다.

'@Override'는 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 때문에 반드시 써주는 것이 좋다.

## 7. 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.

이 둘의 차이는 구현과 확장에 있다. 쉽게 말해 존재의 목적이 다르다.

인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다. 다중 상속이 가능하고 인터페이스를 구현하는 집합 간에 관계가 없을 수도 있다.

추상 클래스는 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용한다. 단일 상송만 가능하고 추상 클래스를 상속하는 집합간에는 연관관계가 있다.

## 8. 클래스는 무엇이고 객체는 무엇인가요?

객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다.

객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한 가지 방법이 클래스이다.

객체는 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체이다.

인스턴스는 객체에 어떤 개념을 적용하는 것이 간능해서 개념 그룹의 일원이 될 때, 객체를 그 개념의 인스턴스라고 한다. 즉, 개념이 객체에 적용 됐을 때, 객체를 개념의 인스턴스라고 한다.

## 9. 정적(static)이란 무엇인가요?

static은 클래스 멤버라고 하며, Class Loader가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스 별로 관리된다.

static 키워드를 통해 생성된 정적 멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있다.

그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료 시까지 메모리가 할당된 채로 존재한다. 너무 남발하면 시스템 성능에 악영향을 줄 수 있다.

## 10. 자바의 원시 타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?

boolean(1), byte(1), char(2), short(2), int(4), long(8), float(4), double(8)

## 11. 접근 제어자의 종류와 이에 대해 설명해주세요.

Java에서의 접근 제어자는 private, default, protected, public으로 볼 수 있다.

private은 해당 클래스 내에서만 접근 가능, default는 해당 패키지, protected는 해당 패키지 뿐만 아니라 상속한 클래스, public은 전체 영역에서 접근 가능하다.

## 12. 객체지향에 대해서 설명해주세요.

객체들이 애플리케이션 기능을 구현하기 위해 수행하는 상호작용을 하는데 이를 협력이라고 한다. 객체가 협력에 참여하기 위해 수행하는 로직을 책임이라고 하고 협력 안에서 책임이 모여서 각자의 역할을 하는 것을 객체지향이라고 한다.

## 13. SOLID에 대해서 설명해주세요.

* SRP (단일 책임 원칙): 하나의 클래스는 하나의 책임만 가져야한다.
* OCP (개방 폐쇄 원칙): 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
* LSP (리스코프 치환 원칙): 인터페이스의 구현체는 인터페이스 기능의 정확성을 깨뜨리면 안된다.
* ISP (인터페이스 분리 원칙): 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
* DIP (의존관계 역전 원칙): 프로그래머는 "추상황에 의존해야지, 구체화에 의존하면 안된다."
