# 3주차 질문 정리

## Collection

Collection의 사전적 의미는 "요소를 수집해서 저장하는 것"이다. 
왜 컬렉션을 사용하는걸까?

우선 다수의 데이터를 다루는데 표준화된 클래스들을 제공해주어 편하게 사용할 수 있다.
또한 배열과는 다르게 객체를 보관하기 위한 공간을 미리 정하지 않아도 되므로 동적으로 값을 추가 및 삭제할 수 있다.

### List
List는 순서가 있는 인터페이스이다. 인덱스 순서로 저장이 되고 중복된 데이터가 저장 가능하다. 객체를 저장하면 자동으로 인덱스가 부여되어 인덱스를 통해 검색 및 삭제가 가능하다.

#### ArrayList

ArrayList는 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.


> 기본 용량이 10인데 이보다 더 많은 원소를 넣을 때 어떻게 동작할까?
> 
> ArrayList 배열 안에는 add() 메소드가 존재한다. add() 메소드 내부를 살펴보면 더 큰 배열에다가 기존 배열의 원소들을 복사한다.

#### LinkedList

LinkedList는 각 노드의 이전, 이후 노드의 상태만 알고 있다.
데이터 탐색 시, 처음부터 노드를 순회해야 하기 때문에 성능상 불리하다.

#### 성능 결론

* 순차적으로 추가/삭제하는 경우 ArrayList가 더 빠르다.
* 중간 데이터를 추가/삭제하는 경우 LinkedList가 더 빠르다.

### Set

Set 인터페이스는 List와 다르게 객체를 중복해서 저장할 수 없다. 또한 객체를 인덱스로 관리하지 않기 때문에 저장 순서가 보장되지 않는다. 하지만 이진 탐색 트리구조로 이루어진 TreeSet을 사용하여 객체를 정렬할 수 있다.

### Map

key, value로 원소를 저장하기 위한 인터페이스다.
Map을 해시테이블을 사용하여 구현한 HashMap 클래스와 이진 탐색 트리 형태로 존재하는 TreeMap 클래스가 있다.

## 프로세스, 쓰레드

### process

프로세스는 실행 중인 프로그램이다. 운영체제로부터 시스템 자원을 할당 받은 단위라고도 설명할 수 있다. 운영체제로부터 자원을 할당 받을 때 각각 독립된 메모리 영역을 할당받는다. 

### thread

쓰레드는 프로세스 내에서 실행되는 흐름의 단위이다. 프로세스 내에 한 개 이상 존재하고 있으며 독립적인 메모리를 가진 프로세스와 달리 stack 영역을 제외하고는 쓰레드끼리 공유가 가능하다. 

### context switching

하나의 프로세스가 인터럽트의 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때, 이전 프로세스의 상태를 보관하고 새로운 프로세스 상태를 교체하는 작업이다.

### 동시성 vs 병렬성

동시성은 두 개 이상의 스레드가 진행 중일 때 존재하는 조건이며, 가상 병렬 처리의 한 형태로 시간 분할을 포함한다. 컴퓨터는 한번에 하나의 명령어만 처리할 수 있다. 우리가 두 개의 스레드가 동시에 진행중인 것 처럼 보이는 것은 스레드간에 빠르게 교차가 일어나기 때문이다. 두 개 이상의 스레드가 교차되며 실행하는 것을 'Context Switching'이라고 한다.

병렬성은 2개 이상의 코어에서 실제로 동시에 명령어를 실행할 수 있다는 것을 말한다. 

### Syncronized

#### Critical Section
멀티 스레드가 구현된 프로그램에서 두 개 이상의 쓰레드가 동시에 하나의 자원의 접근하려고 할 때 제대로 된 값을 얻지 못하는 경우가 있을 수 있다. 이 경우 한번에 하나의 쓰레드에게 접근을 허용해주는 영역을 'Critical Section'이라고 한다. 하나의 쓰레드가 먼저 영역에 접근하면 lock을 걸고 다른 쓰레드가 접근하지 못하게 한다.

자바에서는 Syncronized 예약어를 사용하여 critical section을 지정할 수 있다.

#### Mutex, Spin Lock

Mutex는 lock이 걸려 있을 경우 lock이 풀릴 때까지 기다리며 Context Switching을 실행한다. lock이 풀릴 때까지의 시간이 오래 걸릴 것으로 예상될 때 다른 작업을 동시에 진행할 수 있다. 하지만 자원을 단시간 내로 얻을 수 있을 경우 Context Switching에 더 큰 자원을 낭비할 수 있다.

Spin Lock은 자원에 lock이 걸려 있을 경우 이를 얻을 때까지 무한 루프를 돌면서 다른 테스크에 CPU를 양보하지 않는 것이다.

## IO

input, ouput의 약자이다. 컴퓨터 및 주변 장치에 대하여 데이터의 입출력을 말한다.

### synchronous, asynchronous, blocking, non-blocking

blocking, non-blocking은 동기, 비동기와는 다른 포커스로 봐야한다.
sync, async는 시간의 관점이고, blocking, non-blocking은 제어권의 관점이다.

#### synchronous

하나의 쓰레드에 두 개의 function이 존재할 때, 하나가 끝나면 하나가 실행하는 식으로 서로 시간을 맞추어 실행한다.

#### asynchronous

동기와 반대되는 개념이다.
두 개의 function이 있을 때, 서로 시간을 맞추지 않고 요청에 따라 바로 실행한다.

#### blocking

호출한 function이 자신의 일을 모두 마칠 때까지 제어권을 계속 가지고서 끝날때까지 제어권을 반환해주지 않는다.

#### non-blocking

호출한 function이 할 일을 끝내지 않았더라도 제어권을 반환해줄 수 있다.

#### sync & blocking

프로그램이 데이터를 요청하고 조회하여 반환해줄 때까지 다른 작업을 하지 못한다.

#### sync & non-blocking

프로그램이 데이터를 요청하고 커널에서 데이터를 조회하면서 제어권을 바로 넘긴다.
프로그램에서는 커널에게 작업이 다 되었냐고 물어보고 커널은 완료 또는 미완료 응답을 보내준다.
완료가 된다면 데이터를 받아 다음 작업을 한다.

#### async & blocking

비동기로 실행하여도 제어권을 가지고 있지 않기 때문에 묶여있는 상태가 된다.

#### async & non-blocking
프로그램이 데이터를 요청하고 바로 제어권을 반환하여 다른 일을 할 수 있게 된다.
그리고 데이터가 반환되면 그 데이터를 받아 이전에 수행하던 일을 완료한다.

## TCP, UDP

tcp, udp는 4계층 전송 프로토콜에 속한다.

### TCP (3way, 4way)

tcp는 높은 신뢰성을 가진 연결형 프로토콜이다. 흐름 제어 및 혼잡 제어가 가능하다.

3way handshaking을 통해 연결을 하고 4way handshking을 통해 해제한다.

### UDP

udp는 신뢰성이 낮고 비연결성 방식의 프로토콜이다. 일방적으로 데이터를 보내기 때문에 아무래도 신뢰성보다는 연속성이 중요한 서비스에서 많이 사용된다. 클라이언트와 서버 간의 통신이 없기 때문에 TCP보다 빠른 속도를 보인다.

## JDK8

### 람다식

람다식은 하나의 추상 메소드만 정의되어 있는 인터페이스를 통해 다룰 수 있다.

### Permanent 영역이 없어짐 

Java 7에서 까지는 

> eden -> survivor0 -> survivor1 -> old -> permanent ->>

구조로 되어 있었다. 하지만 java 8에서는 

> eden -> survivor0 -> survivor1 -> old -> metaspace ->>

구조로 바뀌었다.

Permanent 영역은 class, method meta 정보, static 변수와 상수 정보들이 저장되어 있는 공간이었다. 
Java 8에서 JVM 메모리 구조 개선 사항으로 이 영역을 Metaspace 영역으로 전환하였다. 또한 원래 permanent는 JVM에서 관리하는 heap 영역에서 관리했지만 metaspace 영역은 OS 레벨에서 관리하는 native 영역으로 바뀌게 되었다.  

Metaspace가 Native 메모리를 이용함으로서 개발자는 영역 확보의 상한을 크게 의식할 필요가 없어지게 됐다. 

### 메모리 구조

eden | survivor0 | survivor1 | old | metasapce | c heap | thread stack

### 스트림

스트림은 java 8에서 추가된 interface로 데이터 처리 연산을 지원하고 데이터를 다루는데 자주 사용되는 메소드들을 정의해놓았다.

#### 어떤 인터페이스를 사용하는지?

#### lazy evaluation

#### 반복문과 비교해서 언제 효율적으로 동작하는가?

stream은 내부 반복을 사용한다. 내부 반복은 stream 내부에서 자동으로 반복을 처리해주기 때문에 사용자가 직접 반복문을 처리할 필요가 없다. 또한 병렬성 처리의 이점이 있는데, 외부 반복을 사용하는 경우, 명시적으로 컬렉션의 항목을 하나씩 가져와서 처리하게 되는데 stream은 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다.

Stream forEach를 사용할 경우 최종 작업에 사용하는 것이 좋다. forEach안에 로직이 필요한 경우 filter, map, sort를 사용하자.

## ThreadLocal

일반 변수는 특정 블록 범위 내에서만 유효하다.
반면, ThreadLocal을 이용하면 thread 영역에 변수를 설정할 수 있어서 특정 thread가 실행하는 모든 코드에 그 thread에 설정된 변수 값을 사용할 수 있게 된다.

주의해야 할 점은 thread pool 환경에서 ThreadLocal을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해야한다. 그렇지 않으면 재사용되는 thread에서 잘못된 값을 참조할 수 있다.
