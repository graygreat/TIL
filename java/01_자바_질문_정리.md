# 1주차 자바 질문 정리

## 객체 VS 클래스

**클래스**는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구이다. 클래스를 정의하는 것이 먼저가 아니라 **객체들의 속성과 행위를 식별하는 것이 먼저**다. 클래스는 객체의 속성과 행위를 담는 틀일 뿐이다.

**객체**란 상태와 행위를 함께 가지며 스스로 자기 자신을 책임진다. 객체는 행위를 구현하기 위해 메시지를 통해 다른 객체와 협력한다.

객체지향은 정적인 클래스들의 집합이 아니라 메시지를 주고받는 동적인 객체들의 집합으로 바라봐야 한다.

## 변수의 종류

- 클래스 변수
    - 클래스가 처음 호출될 때 시작하여 프로그램이 끝날 때 소멸된다.
- 인스턴스 변수
    - 객체가 생성될 때 생성되어 참조하는 객체가 없을 때 소멸된다.
- 지역 변수
    - 메소드 내에서 유효하다.
- 매개 변수
    - 메소드가 호출될 때 사용 가능하다. '파라미터'라고도 부를 수 있다.

## Primitive Type

자바의 기본형 타입(Primitive Type)은 8가지가 존재한다.
- boolean (1byte)
- byte (1byte)
- short (2byte)
- int (4byte)
- long (8byte)
- float (4byte)
- double (8byte)
- char (2byte)

Primitive Type은 **실제 값**을 저장하는 공간으로 스택 메모리에 저장된다. 


## Reference Type

기본형 타입을 제외한 타입들이 모두 참조형 타입이다. 기본형 타입과 달리 null값을 가질 수 있다.

값이 저장되어 있는 곳의 **주소 값**을 저장하는 공간으로 힙 메모리에 저장된다.

Reference Type은 배열, enum, 클래스(String, Wrapper, ...), 인터페이스가 존재한다.

## 자바의 ==, equals()

자바에서는 두 개의 오브젝트를 비교할 때 동일성, 동등성이라는 말을 사용한다. 동일성은 동일한 오브젝트를 말하고, 동등성은 동일한 정보를 담고 있는 오브젝트를 말한다.
**동일성**은 ==을 사용하고 **동등성**은 equals를 사용한다.

Primitive type은 오브젝트가 아니기 때문에 equals을 사용하여 비교하지 못한다. 단순 값을 비교할 수 있는 ==을 사용하여 비교하면 된다.

## 배열
동일한 자료형의 데이터를 연속된 공간에 저장하기 위한 자료구조이다. 

배열은 힙 영역에서 생성된다. 힙에 생성된 객체와 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조한다.

## JVM
JVM은 Java Virtual Machine의 약자이고 Java가 OS에 상관없이 동작할 수 있도록 해준다.

## Garbage Collection

Java에서 개발자가 코드로 메모리를 관리하지 않기 때문에 가비지 컬렉터가 더 이상 필요없는 객체를 찾아 지우는 작업을 말한다. 

### GC 동작 방식

GC를 실행하기 전에 Stop-the world가 발생하면서 JVM이 GC를 실행하는 쓰레드를 제외하고 모든 작업을 멈춘다.

우리가 사용하는 HotSpot JVM에는 크게 2가지 영역이 존재하는데, 새롭게 생성된 객체 대부분이 존재하는 Young 영역과 Young 영역에서 살아남은 객체가 복사된 Old 영역이 있다. 

Young 영역을 흐름을 보면 Eden영역에 새로 생성한 객체들이 위치하고 이 영역에서 GC가 발생한 후 살아남은 객체는 Survivor영역 중 하나로 이동한다. 그렇게 Survivor영역에 객체가 쌓이고 가득차게 되면 또 다른 Survivor영역으로 이동한다. 이때 가득 찬 Survivor 영역은 비어있는 상태로 바뀐다. 이 과정을 반복하면서 살아남은 객체는 Old 영역으로 이동하게 된다.

Old영역은 기본적으로 데이터가 가득 차면 GC를 실행한다. 

### G1 GC

G1 GC는 데이터가 Young 영역과 Old 영역으로 이동하는 방식이 아닌 바둑판의 각 영역에 객체를 할당하고 GC를 실행하는 방식이다. 해당 영역이 가득 차면 다른 영역에서 객체를 할당하고 GC를 실행한다.

## 접근 제어자

- public
- protected
- default
- private

## 상속 

상속은 **extends** 예약어를 사용한다. 말 그대로 확장을 한다는 것인데, 부모 클래스의 기능을 자식 클래스가 상속 받아 그대로 사용할 수 있게 된다. extends를 사용하여 다중 상속을 할 수 없다. 즉, 하나의 부모 클래스의 기능만 자식 클래스가 사용할 수 있다는 것이다. 우리는 interface를 implements하면서 이러한 문제를 해결할 수 있다.

## Object

Object 클래스는 java.lang 패키지에 속해있는 클래스이다.
모든 클래스의 부모 클래스이기 때문에 import 문을 사용하지 않아도 사용할 수 있다.

Object 클래스에는 여러가지 메소드들이 있다.
toString, equals, clone, hashcode 이 외에도 여러가지 메소드들을 사용할 수 있다.

### equals, hashCode

두 개의 오브젝트를 비교할 때, 동등성과 동일성으로 비교할 수 있다. 

두 개의 오브젝트가 동일성이라면 사실 하나의 오브젝트만 존재하는 것이고 그 하나의 오브젝트를 참조하는 레퍼런스 변수를 가지고 있을 뿐이다. (hashcode가 동일한 것을 통해 이것을 증명할 수 있다.)

동등성인 경우 두 오브젝트를 출력할 경우 hashcode가 다르다고 나온다. 

### 왜 이 둘을 붙여서 설명하는 것일까?

우리는 Object 클래스에서 제공하는 equals를 사용하여 두 오브젝트를 비교하면 동일성을 비교하게 된다. (equals 메소드를 찾아서 들어가보면 == 연산을 하는 것을 확인할 수 있다.)
우리가 동등성을 비교하기 위해 equals를 사용한다면 equals 오버라이딩 하여서 구현해주어야 한다. 

equals 메소드를 사용하여 true를 반환한 두 오브젝트를 HashMap에서 put을 할 때 동일한 key로 인식하고 싶은 경우, 우리는 hashCode 메소드를 오버라이딩하여 해결할 수 있다.

### 결론

equals 메소드를 재정의하여 사용한다면 hashCode 메소드도 재정의하여 사용하는 것이 좋다.