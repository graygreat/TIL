# 4주차 질문 정리

## Web

### 정의

Web은 많은 정보들이 서로 얽혀있는 그물망이라고 볼 수 있다. 

### 구성 요소

- 웹 클라이언트
- 웹 브라우저
- HTTP
- 웹 서버
- 웹 어플리케이션

## HTTP

HTTP는 텍스트 기반의 프로토콜로 웹에서 데이터를 주고받을 수 있는 프로토콜이다.
HTTP는 TCP/IP 기반으로 클라이언트가 요청하고 서버는 응답을 한다.

### 비연결성 (Connectionless)

클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 연결을 끊는다는 것이다.

이 연결을 끊지 않고 계속 유지 한다면, 많은 리소스가 발생하게 된다. 따라서 연결을 끊어 리소스를 줄일 수 있다.

하지만 서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해 매번 새로운 연결 시도/해제의 과정을 거쳐야하므로 오버헤드가 발생한다.

### 비상태성 (Stateless)

비연결성으로 인해 서버가 클라이언트를 식별할 수 없는 상태를 말한다.

쇼핑몰을 예로 들어보자.

HTTP의 특징인 비연결성이 지속적으로 나타난다면, 쇼핑몰에 접속한 후 로그인을 하고 상품을 클릭한 후 로그인을 하고 주문을 한 후 로그인을 해야할 것이다.

즉, 매번 새로운 인증을 해야한다.

이러한 문제는 쿠키, 세션으로 해결할 수 있다.

### TCP는 연결성인데 HTTP는 왜 비연결성인가?

TCP는 3way handshaking을 통해 클라이언트와 서버를 연결한다.

HTTP는 비연결성으로 연결을 매번 끊고 새로 생성하는 구조이다. 이는 비용 측면에서 많은 비용을 소비하는 구조이다. 그래서 HTTP 1.1부터는 keepAlive 기능을 Default로 지원한다.

keepAlive는 연결된 soket에 IN/OUT의 access가 마지막으로 종료된 시점부터 정의된 시간까지 access가 없더라도 대기하는 구조이다. 즉, 정의된 시간 내에 access가 이루어진다면 계속 연결된 상태를 유지할 수 있다.

### HTTPS

HTTPS는 HTTP에 Secure를 추가했다.

일반적인 HTTP의 문제점은 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는다는 것이다. 이러한 문제를 해결하기 위해 HTTPS는 SSL을 사용함으로써 문제를 해결하였다.

SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화한다. 이렇게 전송된 데이터는 중간에서 누군가 가로챈다고 해도 암호화되어 있기 때문에 복호화를 하지 않는 이상 알 수 없다.
그 외에도 TLS 프로토콜을 통해서도 보안을 유지한다.

TLS은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹 사이트와 통신하고 있음을 입증하는 인증 기능도 제공한다.

### OSI 7 Layer

물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용 계층

### keepalive

비연결성으로 인한 오버헤드를 줄이기 위한 해결책으로 keepalive를 사용할 수 있다.

keepalive는 지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우, 상대방의 안부를 묻기 위해 패킷을 주기적으로 보내는 것을 말한다. 이 때 패킷에 반응이 없으면 연결을 끊는다. 

이 방식은 클라이언트의 상태를 주기적으로 체크해야 하기 때문에 완벽한 해결책은 아니다.

HTTP 1.0에서는 KeepAlive를 사용하기 위해 설정을 해야 했지만, HTTP 1.1에서는 default이다.

### chunked streaming

Chunked 방식은 전달하려는 컨텐츠의 사이즈가 큰 경우 서버의 처리 지연을 보완할 수 있는 방법이다.

전체 덩어리를 한번에 주지 않고, 조금씩 떼어 주는 방식이다. 

## HTTP Version

### HTTP 1.0, HTTP 1.1

HTTP 1.0은 요청 컨텐츠마다 TCP 세션을 맺어야 한다. 이와 다르게 HTTP 1.1은 Persistent 기능을 이용하여 한개의 TCP 세션을 통해 여러 개의 컨텐츠 요청이 가능하다.

이 차이점을 통해 서버는 TCP 세션 처리 부하를 줄일 수 있고, 클라이언트 응답 속도를 개선할 수 있다.

#### 파이프라이닝 (Pipelining)

Persistent 기능을 통한 커넥션 유지와 함께 HTTP 1.1에는 파이프라이닝(Pipelining) 기능이 지원된다.

HTTP 요청은 순차적으로 이루어진다. 요청을 하면 응답을 하는 식으로 반복된다.
이러한 경우 앞선 요청에 대해 응답을 하지 않는다면 그 이후의 요청들은 진행되지 못하는 문제가 있다. 그렇기 때문에 비효율적으로 느껴질 수 있다.

이를 개선한 것이 파이프라이닝 기능이다.
동시에 여러 개의 요청을 보내고 각각의 응답을 받아 처리한다.

#### 호스트 헤더 (Host Header)

HTTP 1.0 환경에서는 하나의 IP에 여러 개의 도메인을 운영할 수 없다.
도메인마다 IP를 구분해야 하는데, 그만큼 서버의 개수도 늘어날 수 밖에 없는 구조다.

HTTP 1.1 환경에서는 Host 헤더의 추가를 통해 Virtual 호스팅이 가능해졌다.

#### 강력한 인증 절차 (Improved Authentication Procedure)

HTTP 1.1에서 proxy-authentication, proxy-authorization 2개의 헤더가 추가되었다.

### HTTP 1.1, HTTP 2.0

HTTP 1.1은 다음과 같은 문제가 있다.

* HOL(Head Of Line) Blocking (특정 응답 지연)
* RTT(Round Trip Time) 증가 (양방향 지연)
* 헤더가 크다 (특히 쿠키 때문에)

HTTP 1.1과 비교해서 HTTP 2.0에는 다음과 같은 기능을 제공한다.

#### Multiplexed Streams

한 커넥션에 여러 개의 메시지를 동시에 주고 받을 수 있다.

#### HOL(Head Of Line) Blocking 미발생

HTTP 1.1까지는 한번에 하나의 파일만 전송이 가능했다. 이로 인해 여러 파일을 전송할 경우, 선행 파일의 전송이 늦어지면, 전체 파일 전송의 시간이 늘어나는 문제가 발생했다. (HOL) 

HTTP 2.0에서는 여러 파일을 한번에 병렬 전송하여 이러한 문제를 해결하였다.

#### HTTP Header Data Compression

이전 Header의 내용과 중복되는 필드를 재전송하지 않도록 하여, 데이터를 절약한다. 또한 기존에 HTTP Header가 Plain Text였지만, HTTP 2.0에서는 Huffman Coding을 사용하는 **HPACK**이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높였다.

### HTTP 3.0

TCP/IP 기반의 애플리케이션 프로토콜인 HTTP를 QUIC 위에 얹었ㄷ나는 것이 가장 큰 특징이다.

#### QUIC (Quick UDP Internet Connections)

TCP 기반으로 연결하는 TCP의 성능을 개선하고자 시작된 프로젝트에서 UDP를 채택한 기술이다. 전달 속도의 개선과 더불어 클라이언트와 서버의 연결 수를 최소화하고 대역폭을 예상하여 패킷 혼잡을 피하는 것이 주요 특징이다.

## 쿠키

쿠키는 클라이언트가 서버에게 요청을 보냈을 때, 서버가 응답과 함께 쿠키를 생성해서 보내준다. 클라이언트는 서버로부터 키와 값이 들어있는 데이터인 쿠키를 받아 브라우저에 저장한다. 

쿠키는 유효 시간을 정하게 되면 유효 시간에 따라 브라우저가 종료되어도 쿠키를 유지한다.

쿠키가 생성된 후 요청을 할 경우, HTTP 헤더에 쿠키를 함께 보낸다.

### 브라우저가 쿠키를 서버에 전달하는 이유?

HTTP의 비연결성과 비상태성을 해결할 수 있는 것이 쿠키와 세션이다.

쿠키와 세션 둘 다 연결성과 상태성을 해결하는데, 쿠키와 세션을 나눈 이유는 저장 위치 때문이다. 세션은 서버에 저장되고, 서버 자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하다. 이렇한 자원 관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행하여 사용한다.

### 쿠키에 저장되는 데이터

## 세션

세션은 쿠키와 달리 서버 측에서 관리한다. 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하고 웹 브라우저가 서버에 접속해서 종료할 때까지 세션을 유지한다. 클라이언트가  세션 ID에 대한 쿠키를 저장하고 있다.

### SESSION ID

클라이언트가 서버에 요청을 시도하면 서버는 접근한 클라이언트의 cookie를 확인해 클라이언트가 해당 session id를 보내왔는지 확인한다. 

만약 session id가 존재하지 않는다면, 서버는 session id를 생성해 클라이언트에게 set-cookie 값으로 session id를 발행한다.

세션은 key와 value로 되어 있는데, key 값이 session id 이다.

### JWT (JSON Web Token)

JSON 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token이다.

<추가하기>

### 어느 시점에 처음 생성이 될까?

### 세션에 저장되는 데이터


## 데이터베이스

### JDBC

자바에서 DB 프로그래밍을 하기 위해 사용되는 API이다.

### Connection Pool

WAS가 실행되면서 미리 일정량의 DB Connection 객체를 생성하고 Pool이라는 공간에 저장해둔다. HTTP 요청에 따라 필요할 때 Pool에서 Connection 객체를 가져다 쓰고 반환한다. 이와 같은 방식으로 HTTP 요청 마다 DB 객체를 생성하는 비용을 줄일 수 있다.

#### 동시 접속자가 많을 경우

Pool에서 미리 생성 된 Connection을 제공하고 없을 경우는 사용자는 Connection이 반환될 때까지 번호 순서대로 대기한다.

### Thread Pool

작업 처리에 사용되는 쓰레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 쓰레드가 맡아 처리하는 것이다.
