# 5주차 질문 정리

## 객체지향

객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**이라고 한다.
객체가 협력에 참여하기 위해 수행하는 로직은 **책임**이라고 부른다.
객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

### 앨런 케이의 정의

OOP는 메시징, 상태 처리 과정의 지역적 보존과 보호와 은닉, 그리고 모든 것의 극단적인 지연 바인딩 뿐이다.

### 지연 바인딩

다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 **컴파일 시점이 아닌 실행 시점**에 결정한다는 공통점이 있다.
이를 지연 바인딩(Lazy Binding) 또는 동적 바인딩 (Dynamic Binding)이라고 한다.
객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다.

## UML (Unified Modeling Language)

UML은 모델을 만드는 표준언어이다. 

모델이란 어떤 것을 실제로 만들 때 미리 검증해 보는 것이다. 매번 모델을 만드는 것은 아니며 실제 물건을 만드는 비용보다 비용이 훨씬 적을 경우에 모델을 만들어 설계 검사를 한다.

UML을 사용하는 유형은 다음 3가지 정도가 있다.

* 다른 사람들과의 의사소통 또는 설계 논의
* 전체 시스템의 구조 및 클래스의 의존성 파악
* 유지보수를 위한 설계의 back-end 문서

## abstract

abstract는 상속을 강제하는 일종의 규제이다.

abstract class는 abstract method를 정의하고 class를 상속받은 하위 class가 abstract method를 오버라이딩을 통해 강제로 구현하게 한다.

abstract class는 abstract method 뿐만 아니라 일반적인 method도 정의 가능하다.

## 합성

다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.

## 클래스 생성 시 실행 순서

상위 클래스의 static block -> 하위 클래스의 static block -> 상위 클래스의 instance block -> 상위 클래스의 생성자 -> 하위 클래스의 instance block -> 하위 클래스의 생성자

## final

### final class

final를 통해 클래스 상속을 제한할 수 있다. 대표적으로 String이 있다.

class를 final로 정의함으로서 얻을 수 있는 장점은 아래와 같다.

1. Immutable objects
2. Security
3. Performance

### final method

final를 통해 메소드 오버라이드 제한한다.

### final variable

final를 통해 Immutable 선언을 한다.

## instanceof

instanceof는 객체 타입을 확인하는데 사용한다. 

(참조변수) + instanceof + (타입)의 형태로 존재하고 연산의 결과로 true, false를 반환한다.

## this, super

this는 현재 인스턴스화 된 객체의 자신을 가리킨다.

super는 현재 상위 클래스를 상속받은 하위 클래스에서 상위 클래스의 변수와 메서드에 접근하기 위해 사용한다.

this()는 현재 클래스에 정의된 생성자를 부를 때 사용한다.

super()는 하위 클래스가 자신을 생성할 때 상위 클래스의 생성자를 불러 초기화 할 때 사용한다.

