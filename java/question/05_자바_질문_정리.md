# 5주차 질문 정리

## 객체지향

객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**이라고 한다.
객체가 협력에 참여하기 위해 수행하는 로직은 **책임**이라고 부른다.
객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

### 앨런 케이의 정의

OOP는 메시징, 상태 처리 과정의 지역적 보존과 보호와 은닉, 그리고 모든 것의 극단적인 지연 바인딩 뿐이다.

### 지연 바인딩

다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 **컴파일 시점이 아닌 실행 시점**에 결정한다는 공통점이 있다.
이를 지연 바인딩(Lazy Binding) 또는 동적 바인딩 (Dynamic Binding)이라고 한다.
객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다.

## UML (Unified Modeling Language)

UML은 모델을 만드는 표준언어이다. 

모델이란 어떤 것을 실제로 만들 때 미리 검증해 보는 것이다. 매번 모델을 만드는 것은 아니며 실제 물건을 만드는 비용보다 비용이 훨씬 적을 경우에 모델을 만들어 설계 검사를 한다.

UML을 사용하는 유형은 다음 3가지 정도가 있다.

* 다른 사람들과의 의사소통 또는 설계 논의
* 전체 시스템의 구조 및 클래스의 의존성 파악
* 유지보수를 위한 설계의 back-end 문서

## 객체지향의 특성

### 캡슐화

객체의 자율성을 보전하기 위해 구현을 외부로부터 감추는 것이다. 

송신자는 자신의 요구를 메시지로 전달할 뿐, 객체의 상태 변화를 포함한 내부 사정은 몰라야한다.
객체는 상태를 캡슐 안에 감추고 외부로 노출하는 것은 행동 뿐이다.
외부에서 객체로 접근할 수 있는 방법 역시 행동 뿐이다.

### 추상화

추상화는 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복할 수 있다.
즉, 복잡성을 이해하기 쉬운 수준으로 단순화 할 수 있다.

### 상속

상위 클래스의 기능을 하위 클래스가 확장하는 것이다.

### 다형성

동일한 역할을 수행할 수 있는 개체들 사이의 대체 가능성을 말한다.
다형성을 만족시킨다는 말은 객체들이 동일한 책임을 공유한다는 말과 같다.

다형성을 사용하면 설계를 유연하고 재사용 가능하게 만든다.

## 클래스

객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다.
객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한 가지 방법이 클래스이다.

## 객체

객체는 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체이다.

## 인스턴스

객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때, 객체를 그 개념의 인스턴스라고 한다.
즉, 개념이 객체에 적용 됐을 때, 객체를 개념의 인스턴스라고 한다.

## 구현

객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다.

인터페이스와 구현을 분리해야한다.

## abstract

abstract는 상속을 강제하는 일종의 규제이다.

abstract class는 abstract method를 정의하고 class를 상속받은 하위 class가 abstract method를 오버라이딩을 통해 강제로 구현하게 한다.

abstract class는 abstract method 뿐만 아니라 일반적인 method도 정의 가능하다.

## 합성

다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.

## 클래스 생성 시 실행 순서

상위 클래스의 static block -> 하위 클래스의 static block -> 상위 클래스의 instance block -> 상위 클래스의 생성자 -> 하위 클래스의 instance block -> 하위 클래스의 생성자

## final

### final class

final를 통해 클래스 상속을 제한할 수 있다. 대표적으로 String이 있다.

class를 final로 정의함으로서 얻을 수 있는 장점은 아래와 같다.

1. Immutable objects
2. Security
3. Performance

### final method

final를 통해 메소드 오버라이드 제한한다.

### final variable

final를 통해 Immutable 선언을 한다.

## instanceof

instanceof는 객체 타입을 확인하는데 사용한다. 

(참조변수) + instanceof + (타입)의 형태로 존재하고 연산의 결과로 true, false를 반환한다.

## this, super

this는 현재 인스턴스화 된 객체의 자신을 가리킨다.

super는 현재 상위 클래스를 상속받은 하위 클래스에서 상위 클래스의 변수와 메서드에 접근하기 위해 사용한다.

this()는 현재 클래스에 정의된 생성자를 부를 때 사용한다.

super()는 하위 클래스가 자신을 생성할 때 상위 클래스의 생성자를 불러 초기화 할 때 사용한다.

