## Clustered Index, Secondary Index

Clustered index는 테이블당 한 개만 생성할 수 있고, Secondary Index는 테이블당 여러 개를 생성할 수 있다. 또, Clustered Index는 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다.

UNIQUE에 NOT NULL이 포함되면 Clustered Index로 지정된다.

MySQL에서 Index는 기본적으로 B-Tree 구조를 사용하는데, 이 구조는 데이터를 검색할 때 아주 뛰어난 성능을 발휘한다.

B-Tree 구조는 루트 페이지, 리프 페이지로 구성 되어 있다. 루트 페이지를 검색한 후 해당 데이터 정보를 찾아 리프 페이지로 직접 이동한다.

하지만 B-Tree 구조가 마냥 좋은 것만은 아니다. 

B-Tree 구조는 데이터 변경 작업(insert, update, delete) 시에 성능이 나빠지는 단점이 있다. 그 이유는 '페이지 분할' 작업이 발생되기 때문이다.

Clustered Index는 루트 페이지와 리프 페이지(중간 페이지가 있다면 중간 페이지도 포함)로 인덱스가 구성되어 있으며 동시에 인덱스 페이지의 리프 페이지는 데이터 그 자체이다.

Secondary Index는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성한다. 우선, 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열을 정렬한다. 그리고 데이터 위치 포인터를 생성한다.
데이터의 위치 포인터는 Clustered Index와 달리 주소값(페이지 번호 + #오프셋)이 기록되어 바로 데이터의 위치를 가리키게 된다.

Secondary Index는 데이터 페이지를 정렬하는 것이 아니므로, 그냥 데이터 페이지의 뒤쪽 빈 부분에 삽입된다. 그리고 인덱스의 리프 페이지에도 약간의 위치가 조정된 것일뿐 페이지 분할은 일어나지 않는다.
결국, Clustered Index보다 데이터 입력에서는 성능에 주는 부하가 더 적다.

## ACID

ACID는 Transaction이 안전하게 수행된다는 것을 보장하기 위한 특징이다.

### Atomicity(원자성)

DB에 모두 반영되거나, 전혀 반영되지 않아야 한다. (All or Nothing)

### Consistency(일관성)

DB 상태가 일관된 상태였다면 트랜잭션 작업이 종료된 후에도 일관성 있는 상태를 유지해야한다.

### Isolation(독립성)

둘 이상의 트랜잭션이 동시 실행되고 있을 때, 각각의 Transaction은 독립적으로 이루어져 어떤 트랜잭션도 다른 Transaction 연산에 끼어들 수 없다.

### Durability(지속성, 영구성)

트랜잭션이 성공적으로 완료되었으면 결과는 영구히 반영되어야 한다.


## Deadlock 시나리오

1. 프로세스1은 자원1을 점유한다.
2. 프로세스2는 자원2를 점유한다.
3. 프로세스1은 자원2를 사용해야 하지만 프로세스1이 점유하고 있기 때문에 대기한다.
4. 프로세스2는 자원1을 사용해야 하지만 프로세스2가 점유하고 있기 때문에 대기한다.
5. 이렇게 되면 프로세스1, 프로세스2는 서로 자원을 얻기 위해 대기하면서 deadlock에 빠진다.

